kotlin
de claração de variavel = var
constante = val 
código começa com chamada de função = fun(){

}

os tipos numericos inteiros podem ser classficados: 
Byte : 8 bits  |   min  -128  |    max    127  |
Short : 16 bits  |  min  -32768  | max  32767  |
Int : 32 bits| min-2,147,483,648 (-231) |max 2,147,483,647 (231 - 1)  |
Long : 64bits| min -9,223,372,036,854,775,808 (-263) | max 9,223,372,036,854,775,807 (263 - 1)  |

para especificar a classificação do tipo, usar a seguinte escrita:

val nomedavariavel: Byte = valor
val nomedavariavel: Short = valor
val nomedavariavel = os valores inteiros não precisam de especificação
val nomedavariavel: Long = valor ou val nomedavariavel = valorL


no caso de valores reais as classificações são as desempre, float e double:

float:
 var nomedavariavel = valorf (Exs: 1.2f,  3.92f, 2.349f)

 float pode ter etre 6 e 7 casas decimais  e o double entre 15 e 16

 double:
 var nomedavariavel: Double = valor

 para verificar o tipo do dado armazenado é possível utilizar println(nomedavariavel is Int) o nome do tipo deve começar com a letra maiuscula, o retorno será true ou false. 

 para converter o tipo do dado utiliza-se a função toNomedodado, ex:
 println(nomedavariavel.toFloat)
 println(nomedavariavel.toDouble)


 *importante - as conversões só podem ser feitas com dados que caibam no tipo, tendo como referencia o valor minimo e maximo de cada tipo

 *Importante - em caso de divisão em que o resultado da operação utilizando dois inteiros for um valor com ponto flutuante, deve se escrever dessa forma. 

 val nomedavariavel = 5.toDouble()/2.toDouble 

 ou

 val nomedavariavel = 5f/2f
 
 ou

 val nomedavariavel = 5f/2 (ou 5/2f)

 No caso acima o resultado será 2.5 se não houver conversão o valor será apenas 2

 *usando os operadores de comparação só é possível comparar dados do mesmo tipo, caso contrário ocorrerá erro na saída. 
 ex: 
 val a = 2
 val b:Short = 2

 println(a==b) - nesse caso a saída será um erro

 println(a==b.toInt()) - nesse caso a saída será true


 a escrita das estruturas condicionais se assemelham as demais linguagens



funções

fun nomeDaFunção() {

}

para fazer passagem de  parametros é importante especificar o tipo do parametro,ex:

  fun mandarOi(nome: String){
      println("Oi ${nome}")
  }
  mandarOi("Gabriel")


  para ter um valor padrão no parametro pode-se utilizar essa sintaxe:

  fun mandarOi(nome: String = "Desconhecido"){
     println("Oi ${nome}")
  }
  
  mandarOi() - a saída será Oi Desconhecido

  A passagem de parametro é obrigatoria caso exista uma chamada no escopo da função, se não for passado nenhum parametro e não houver um valor padrão, a saída será um erro. 

  funções que retornam valores, precisam ter o tipo do retorno espeficiado. ex:

  fun soma (a : Int, b: Int): Int{
    return a+b
}

println(soma(2,3))

uma forma mais fácil de escrever a mesma função é:
fun soma(a : Int, b : Int): Int = a + b
 println(soma(2,3))


 loops


 while:

 sintaxe de uma estrutura de repetição while, potencia:

fun potencia (base: Int, exp: Int): Int{
    var resultado = base
    var repeticoes = exp -1
    while (repeticoes != 0){
        
        resultado = resultado*base
        repeticoes--
        
    }
  
    return resultado
}
  println(potencia(2,3))



  For:

  função usando estrutura for

  fun potencia (base: Int, exp: Int): Int{
    var resultado = base
    var repeticoes = exp -1
    
    for (i in 1.. exp-1){
        
        resultado = resultado*base
       
        
    }
  
    return resultado
}
  println(potencia(2,3))

  outro exemplo:

  for(i in 0.. 3){
    
    println(i)
}

saída: 0, 1, 2, 3



arrays em java:

formas de declarar:

*em Kotlin vc pode dizer a capacidade da array, caso não seja especificado a capacidade inicial será 10 posições. 


lista de inteiros vazia sem definir a capacidade:
val listaDeInteiros = ArrayList<Int>()


lista de Strings de capacidade 5:
avl listaDeStrings = arrayListOf<String>(5)

lista de inteiros com 6 itens:
val sequenciaDeInteiros = arrayListOF<Int>(1, 2, 3, 4, 5, 6)

se o conteúdo já forexpecificados é opcional dizer o tipo:

val semEspecificarOTipo = ("José", "João", "Maria")


como varrer uma array usando for:

val sequencia = arrayListOf <Int> (1, 2, 3, 4, 5, 6);
for(i in sequencia){
    
    println(i)
}


outra forma de escrever um loop for com array:

val convidados = arrayListOf ("José", "João", "Maria")
for((index, i) in convidados.withIndex()){
    
println("convidado: $index $i ")

}

saída:

convidado: 0 José 
convidado: 1 João 
convidado: 2 Maria 



as palavras reservadas "continue" e "break" funcionam de forma similar ao JS


